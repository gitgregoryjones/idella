var CSSTEXT_HARDCODEDCSSTEXT = "common-id:abc;common-alias:none;common-color:white;common-href:none;common-height: 1200px; common-width: 858.469px; common-top: auto; common-left: auto; common-border:border;common-border-radius:0px;common-position:relative;common-z-index: auto;api-API:www.mock.com; api-body:{};api-response:{}; api-submit:Go;  common-onhover:{}; dialog-enabled:yes;animation-delay: 0s;slider-auto-slide:false;slider-delay:0px;slider-speed:0.6s;slider-direction:none;animation-fun:none;  animation-direction: normal; animation-duration: 0s; animation-fill-mode: none; animation-iteration-count: 1; animation-name: none; animation-play-state: running; animation-timing-function: ease;background-image: none; background-attachment: scroll; background-blend-mode: normal; background-clip: border-box; background-color: rgb(244, 244, 244);  background-origin: padding-box; background-position: 0% 0%; background-repeat: repeat; background-size: auto;  align:left;  border-bottom-color: rgb(0, 0, 0); border-bottom-left-radius: 0px; border-bottom-right-radius: 0px; border-bottom-style: none; border-bottom-width: 0px; border-collapse: separate; border-image-outset: 0px; border-image-repeat: stretch; border-image-slice: 100%; border-image-source: none; border-image-width: 1; border-left-color: rgb(0, 0, 0); border-left-style: none; border-left-width: 0px; border-right-color: rgb(0, 0, 0); border-right-style: none; border-right-width: 0px; border-top-color: rgb(0, 0, 0); border-top-left-radius: 0px; border-top-right-radius: 0px; border-top-style: none; border-top-width: 0px; bottom: auto; box-shadow: none; box-sizing: content-box; break-after: auto; break-before: auto; break-inside: auto; caption-side: top; clear: none; clip: auto;  content: ; direction: ltr; display: block; empty-cells: show; float: none; font-family: Times; font-kerning: auto; font-size: 16px; font-stretch: normal; font-style: normal; font-variant: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-numeric: normal; font-weight: normal;  image-rendering: auto; isolation: auto; letter-spacing: normal; line-height: normal; list-style-image: none; list-style-position: outside; list-style-type: disc; margin-bottom: 8px; margin-left: 8px; margin-right: 8px; margin-top: 8px; max-height: none; max-width: none; min-height: 0px; min-width: 0px; mix-blend-mode: normal; motion-offset: 0px; motion-path: none; motion-rotation: auto 0deg; object-fit: fill; object-position: 50% 50%; opacity: 1; orphans: 2; outline-color: rgb(0, 0, 0); outline-offset: 0px; outline-style: none; outline-width: 0px; overflow-wrap: normal; overflow-x: visible; overflow-y: visible; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; pointer-events: auto; resize: none; right: auto; speak: normal; table-layout: auto; tab-size: 8; text-align: start; text-align-last: auto; text-decoration: none; text-indent: 0px; text-rendering: auto; text-shadow: none; text-size-adjust: auto; text-overflow: clip; text-transform: none;  touch-action: auto; transition-cntrl-left:left; transition-cntrl-right:right;transition-duration: 0s;  transition-number-items: 1;  transition-delay: 0s;  transition-property: all; transition-timing-function: ease; unicode-bidi: normal; vertical-align: baseline; visibility: visible; white-space: normal; widows: 2; will-change: auto; word-break: normal; word-spacing: 0px; word-wrap: normal; zoom: 1; -webkit-transition-duration:0s;-webkit-appearance: none; backface-visibility: visible; -webkit-background-clip: border-box; -webkit-background-origin: padding-box; -webkit-border-horizontal-spacing: 0px; -webkit-border-image: none; -webkit-border-vertical-spacing: 0px; -webkit-box-align: stretch; -webkit-box-decoration-break: slice; -webkit-box-direction: normal; -webkit-box-flex: 0; -webkit-box-flex-group: 1; -webkit-box-lines: single; -webkit-box-ordinal-group: 1; -webkit-box-orient: horizontal; -webkit-box-pack: start; -webkit-box-reflect: none; -webkit-clip-path: none; column-count: auto; column-gap: normal; column-rule-color: rgb(0, 0, 0); column-rule-style: none; column-rule-width: 0px; column-span: none; column-width: auto; align-content: normal; align-items: stretch; align-self: stretch; flex-basis: auto; flex-grow: 0; flex-shrink: 1; flex-direction: row; flex-wrap: nowrap; justify-content: normal; -webkit-font-smoothing: auto; -webkit-highlight: none; -webkit-hyphenate-character: auto; -webkit-line-break: auto; -webkit-line-clamp: none; -webkit-locale: auto; -webkit-margin-before-collapse: collapse; -webkit-margin-after-collapse: collapse; -webkit-mask-box-image: none; -webkit-mask-box-image-outset: 0px; -webkit-mask-box-image-repeat: stretch; -webkit-mask-box-image-slice: 0 fill; -webkit-mask-box-image-source: none; -webkit-mask-box-image-width: auto; -webkit-mask-clip: border-box; -webkit-mask-composite: source-over; -webkit-mask-image: none; -webkit-mask-origin: border-box; -webkit-mask-position: 0% 0%; -webkit-mask-repeat: repeat; -webkit-mask-size: auto; order: 0; perspective: none; perspective-origin: 429.234px 600px; -webkit-print-color-adjust: economy; -webkit-rtl-ordering: logical; shape-outside: none; shape-image-threshold: 0; shape-margin: 0px; -webkit-tap-highlight-color: rgba(0, 0, 0, 0.4); -webkit-text-combine: none; -webkit-text-decorations-in-effect: none; -webkit-text-emphasis-color: rgb(0, 0, 0); -webkit-text-emphasis-position: over; -webkit-text-emphasis-style: none; -webkit-text-fill-color: rgb(0, 0, 0); -webkit-text-orientation: vertical-right; -webkit-text-security: none; -webkit-text-stroke-color: rgb(0, 0, 0); -webkit-text-stroke-width: 0px; transform: none; transform-origin: 429.234px 600px; transform-style: flat; -webkit-user-drag: auto; -webkit-user-modify: read-only; -webkit-user-select: text; -webkit-writing-mode: horizontal-tb; -webkit-app-region: no-drag; buffered-rendering: auto; clip-path: none; clip-rule: nonzero; mask: none; filter: none; flood-color: rgb(0, 0, 0); flood-opacity: 1; lighting-color: rgb(255, 255, 255); stop-color: rgb(0, 0, 0); stop-opacity: 1; color-interpolation: sRGB; color-interpolation-filters: linearRGB; color-rendering: auto; fill: rgb(0, 0, 0); fill-opacity: 1; fill-rule: nonzero; marker-end: none; marker-mid: none; marker-start: none; mask-type: luminance; shape-rendering: auto; stroke: none; stroke-dasharray: none; stroke-dashoffset: 0px; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-opacity: 1; stroke-width: 1px; alignment-baseline: auto; baseline-shift: 0px; dominant-baseline: auto;text-orientation:horizontal; text-anchor: start; writing-mode: horizontal-tb; vector-effect: none; paint-order: fill stroke markers; d: none; cx: 0px; cy: 0px; x: 0px; y: 0px; r: 0px; rx: auto; ry: auto;";
//misc-class:none;misc-position: static;misc-loop:loop;misc-autoplay:true;misc-cursor: auto;border:none; common-src:none;border-border: none;

var CSSTEXT_validStyles = {}; 

CSSTEXT_HARDCODEDCSSTEXT.split(";").forEach(function(style){
	var nd = style.split(":");
	if(nd){
	CSSTEXT_validStyles[nd[0].trim()] = nd[1]
	}
})



function writeClassToBreakPointCSSFile(div, myCSSLookupKey,theClassObj,justTestIfExists){

	var re = new RegExp(myCSSLookupKey+'\\s+\\{[^}]+\\}','img')

	var exists = false;

	var thescript = $("style.max-width-"+currentBreakPoint)
	log.debug("CSSTEXT.js: " + myCSSLookupKey);
	log.debug("CSSTEXT.js: The CSS RULE")
	log.debug("CSSTEXT.js: " + theClassObj.cssRule);

	//temp remove last Brace.  Will add back after append
	thescript.html(thescript.html().substring(0,thescript.html().lastIndexOf("}") ) );

	styleCss = thescript.html();


	//test to see if style is not found, add it.  If found, replace it
	if(!thescript.html().match(re)){

		thescript.append(theClassObj.cssRule);
	}else {
		if(justTestIfExists){
			exists = true;
			return exists;
		}
		thescript.html(thescript.html().replace(re,theClassObj.cssRule))
		
	}

	thescript.html(thescript.html().trim() + "\n}")
		
	log.debug("CSSTEXT.js: Almost done " + website)

	

	/*
	theSiteObj.bp = BREAKPOINTS; 

	for(points in BREAKPOINTS){

		var cbp = BREAKPOINTS[points]

		log.debug("CSSTEXT.js: Retrieving site at breakpoint " + cbp);

		theSiteObj["@media-"+cbp] = $("style.max-width-"+cbp).addClass("generated").html()
	}*/

	return exists;
}

function addIdellaClassToElementWithCallback(className, element,callback){

	var re = new RegExp(className.replace(".","\\.")+'\\s+(\\{([^}]+)\\})','img')

	var thescript = "";

	var exists = false;

	$.get("/css/idella.css",function(data){

		console.log(`Data is ${data}`)
		let m = null;

		if ((m = re.exec(data)) !== null) {

			console.log(`returning ${m[2]}`);

			var lines = m[2].trim().split(";")

			for(idx in lines){
				console.log(`Line was ${lines[idx].trim()}`)
				if(lines[idx].length > 0){

					var key = lines[idx].substr(0,lines[idx].indexOf(":")).trim();
					var value = lines[idx].substr(lines[idx].indexOf(":") + 1).trim();

					console.log(`Value is ${key},${value}`)

					if(className.indexOf(":hover") > -1){

						$(element).attr("onhover",($(element).attr("onhover")? $(element).attr("onhover"):"") + lines[idx] + ";");

					} else if(className.indexOf(":active") > -1){

						$(element).attr("onactive",$(element).attr("onhover") + lines[idx]);

					} else {
						element.css(key,value);
					}
				}				
			}

			callback(element);

			return;

		} else {

			console.log(`I didn't find a match in idella`)

			callback(element);
		}
	})

	//Do hover and active
	if(className.indexOf(":hover") == -1 && className.indexOf(":active") == -1){

		addIdellaClassToElementWithCallback(className + ":hover", element,function(){});
		addIdellaClassToElementWithCallback(className + ":active", element,function(){})

	}

}


function addIdellaClassToElement(styleSheetName,selector, element,styleSheetSource){

	console.log(`User wants to read classname ${selector}`)

	var re = new RegExp(selector.replace(".","\\.")+'\\s+(\\{([^}]+)\\})','img')

	var thescript = "";

	var exists = false;

	var sheet = $(`link[href*=${styleSheetName}]`);

	console.log(`I found exactly ${sheet.length} matches for ${styleSheetName} calling ${sheet.attr("href")}`)

	if(!styleSheetSource){
		console.log(`Stylesheet source was not passed for class ${selector}`);
		$.get({url:sheet.attr("href"), async:false})
		.done(function(data){
			console.log("I'm back")
			styleSheetSource = data;
		})
	} 

	console.log("source is " + styleSheetSource)

	if ( (m = re.exec(styleSheetSource) )!== null  ) {

			console.log(`returning ${m}`);

			var lines = m[2].trim().split(";")

			for(idx in lines){
				console.log(`Line was ${lines[idx].trim()}`)
				if(lines[idx].length > 0){

					var key = lines[idx].substr(0,lines[idx].indexOf(":")).trim();
					var value = lines[idx].substr(lines[idx].indexOf(":") + 1).trim();

					console.log(`Value is ${key},${value}`)

					if(selector.indexOf(":hover") > -1){

						$(element).attr("onhover",($(element).attr("onhover")? $(element).attr("onhover"):"") + lines[idx] + ";");

					} else if(selector.indexOf(":active") > -1){

						$(element).attr("onactive",$(element).attr("onhover") + lines[idx]);

					} else {
						element.css(key,value);
					}
				}				
			}

			var result = [];

			result.push(m[2])

			//Do hover and active
			if(selector.indexOf(":hover") == -1 && selector.indexOf(":active") == -1){

				var hoverClassDef  = addIdellaClassToElement(styleSheetName, selector + ":hover", element,styleSheetSource);
				var activeClassDef = addIdellaClassToElement(styleSheetName,selector + ":active", element,styleSheetSource)

				if(hoverClassDef.length > 0){
					result.push(hoverClassDef.pop())
				}

				if(activeClassDef.length > 0){
					result.push(activeClassDef.pop())
				}
				

			}

			return result;

	} else {

		console.log(`I didn't find a match in ${styleSheetSource} for ${selector}`)

		return [];
	}

}





function writeClassToMasterCSSFile(div, myCSSLookupKey,theClassObj,justTestIfExists,pageNode){



	var re = new RegExp(myCSSLookupKey+'\\s+\\{[^}]+\\}','img')

	var thescript = "";

	var exists = false;

	log.debug("CSSTEXT.js: My Class should be persisted as")
	log.debug("CSSTEXT.js: " + theClassObj.cssRule)

	

	thescript = div.attr("id").startsWith("contentCopyFor-")? $("#pageStylesCopy") : $("#pageStyles");

	

	styleCss = thescript.html();
	//test to see if style is not found, add it.  If found, replace it
	if(!thescript.html().match(re)){
		log.debug("Error CSSTEXT.js: Appending RULE for " + myCSSLookupKey + " and rule " + theClassObj.cssRule)
		thescript.append(theClassObj.cssRule + "\n");
	}else {
		if(justTestIfExists){
			exists = true;
			return exists;
		}
		log.info("CSSTEXT.js: I found  RULE for " + myCSSLookupKey )
		log.info(`CSSTEXT.js: Replacing with ${theClassObj.cssRule}`)

		thescript.html(thescript.html().replace(re,theClassObj.cssRule))
	}


	//If we just wrote to pageStyles (for offscreen save), don't forget to get the hover styles for the element and append to the pageStyleCopy script
	if(thescript[0].id == "pageStylesCopy"){

		//Get :Hover class from pageStyles CSS

		var hoverRegex = new RegExp("body.hover ."+  myCSSLookupKey.substr(myCSSLookupKey.indexOf("-")+1) +":hover"+'\\s+\\{[^}]+\\}','img');
		var matches = [];
		if((matches = $("#pageStyles").html().match(hoverRegex)) != null){
			console.log(`Found a match for ${myCSSLookupKey}:hover and now I'm appending to pageStylesCopy with value ${matches[0]}`);
			thescript.append(matches[0]);

		}else {
			//No Hover Method found for 
			console.log(`Did not find a hover rule that matched body.hover  .${myCSSLookupKey.substr(myCSSLookupKey.indexOf("-")+1)}:hover\\s+\\{[^}]+\\}`);
		}
	}


	return exists;
}

function doWebkitHoverColor(div){
	var regex = /((^|[^-])color):([^;]+)(\s|;|$)/g;
	//const str = `-webkit-text-fill-color:red;background-color:blue;color:red;border-color:orange`;


	
	var str = div.attr("onhover");


	let m = null;

	

	if ((m = regex.exec(str)) !== null) {
	    // This is necessary to avoid infinite loops with zero-width matches
	    if (m.index === regex.lastIndex) {
	        regex.lastIndex++;
	    }
	    
	   var color=m[3];

	   

	   log.debug("Value of M")
	   log.debug(m);
	   log.debug("Str before is " + str);
	   //str = "-webkit-text-fill-color:"+color+";" + str;
	   str= str.replace(m[0],"-webkit-text-fill-color:"+color);

	   log.debug("CSSTEXT.js: onHover string is " + str)
	    div.attr("onhover",str);
	   
	 } else {
	 	log.debug("OnHover attribute was not triggered " + str);
	 }
}


function CSS_TEXT_saveCss(div, theClassObj) {
//theClassObj = theClassObj ? CONVERT_STYLE_TO_CLASS_OBJECT($(div)) : theClassObj
	div = $(div);

	var myId = $(div).attr("id");

	var myCSSLookupKey = "[\\.|#]" + $(div).attr("id")

	//if onhover, do color manipulation logic for webkit
	doWebkitHoverColor(div);

	if(isBreakPoint()){

		writeClassToBreakPointCSSFile(div, myCSSLookupKey,theClassObj)
		//Do Hover of attribute for object. Ugly but necessary. Without Else statement we would have left over ELEMENT:hover classes
		//in css when user clear the onhover attribute from #editSpace

		if(div.attr("onhover")){

			var outStr = "body.hover ." + div.attr("id") + ":hover {\n";

			outStr += "\t" + $(div).attr("onhover") + "\n";
			
			outStr += "}";
			theClassObj.cssRule = outStr;

			writeClassToBreakPointCSSFile(div,"body.hover "+ myCSSLookupKey+":hover",theClassObj);

			
		} else {
			//theClassObj.cssRule = "";
			//writeClassToBreakPointCSSFile(div,"body.hover "+myCSSLookupKey + ":hover",theClassObj);		
		}

	} else {
		writeClassToMasterCSSFile(div,myCSSLookupKey,theClassObj);
		//Do Hover of attribute for object. Ugly but necessary. Without Else statement we would have left over ELEMENT:hover classes
		//in css when user clear the onhover attribute from #editSpace

		if(div.attr("onhover")){
			var outStr = "body.hover ." + div.attr("id") + ":hover {\n";

			outStr += "\t" + $(div).attr("onhover") + "\n";
			
			outStr += "}";
			theClassObj.cssRule = outStr;
			log.debug("CSSTEXT.js: Anchor rule")
			log.debug("CSSTEXT.js: " + theClassObj.cssRule)

			writeClassToMasterCSSFile(div,"body.hover "+myCSSLookupKey+":hover",theClassObj);	

				


		} else {
			//theClassObj.cssRule = "";
			//writeClassToMasterCSSFile(div,"body.hover " + myCSSLookupKey + ":hover",theClassObj);		
		}

		
	}

	log.debug("CSSTEXT.js: Style before is " + div.attr("style"))

	div.removeAttr("style");
	div.removeAttr("onhover");
	div.removeAttr("onactive")
	log.debug("CSSTEXT.js: Style is " + div.attr("style"))

	
}
//module.exports.CSSTEXT_HARDCODEDCSSTEXT;
//module.exports.CSSTEXT_validStyles;
